import type { CodeSymbol } from "../indexer/symbol.types.js";
import type { DetectedPattern } from "../patterns/patternAnalyzer.js";
import type { RelationshipRow } from "../storage/db.js";
import { CSS } from "./styles.js";
import { fileSlug, buildMermaidForSymbol } from "./shared.js";

export { fileSlug };

function escapeHtml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function badgeClass(kind: string): string {
  const map: Record<string, string> = {
    class: "badge-class",
    abstract_class: "badge-class",
    interface: "badge-interface",
    function: "badge-function",
    method: "badge-method",
    enum: "badge-enum",
    type: "badge-type",
  };
  return map[kind] ?? "badge-class";
}

function nav(current: string, depth: number): string {
  const prefix = depth > 0 ? "../".repeat(depth) : "";
  const links = [
    [`${prefix}index.html`, "Dashboard"],
    [`${prefix}relationships.html`, "Relationships"],
    [`${prefix}patterns.html`, "Patterns"],
  ];
  const base = current.split("/").pop() ?? current;
  return `<nav>${links
    .map(
      ([href, label]) =>
        base === href.split("/").pop()
          ? `<strong>${label}</strong>`
          : `<a href="${href}">${label}</a>`,
    )
    .join("")}</nav>`;
}

function layout(title: string, currentPage: string, body: string, depth = 0): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${escapeHtml(title)} - doc-kit</title>
  <style>${CSS}</style>
</head>
<body>
  ${nav(currentPage, depth)}
  ${body}
  <footer>Generated by doc-kit</footer>
</body>
</html>`;
}

export interface SiteData {
  symbols: CodeSymbol[];
  relationships: RelationshipRow[];
  patterns: DetectedPattern[];
  files: string[];
}

export function renderDashboard(data: SiteData): string {
  const { symbols, relationships, patterns, files } = data;

  const kindCounts: Record<string, number> = {};
  for (const s of symbols) {
    kindCounts[s.kind] = (kindCounts[s.kind] ?? 0) + 1;
  }

  const topLevel = symbols.filter((s) => !s.parent);

  const body = `
    <h1>doc-kit Documentation</h1>

    <div class="stats">
      <div class="stat">
        <div class="number">${files.length}</div>
        <div class="label">Files</div>
      </div>
      <div class="stat">
        <div class="number">${symbols.length}</div>
        <div class="label">Symbols</div>
      </div>
      <div class="stat">
        <div class="number">${relationships.length}</div>
        <div class="label">Relationships</div>
      </div>
      <div class="stat">
        <div class="number">${patterns.length}</div>
        <div class="label">Patterns</div>
      </div>
    </div>

    <h2>Symbol Kinds</h2>
    <div class="stats">
      ${Object.entries(kindCounts)
        .sort((a, b) => b[1] - a[1])
        .map(
          ([kind, count]) => `
        <div class="stat">
          <div class="number">${count}</div>
          <div class="label">${kind}</div>
        </div>`,
        )
        .join("")}
    </div>

    <h2>Files</h2>
    <ul class="file-tree">
      ${files
        .sort()
        .map(
          (f) =>
            `<li><a href="files/${fileSlug(f)}.html">${escapeHtml(f)}</a></li>`,
        )
        .join("")}
    </ul>

    <h2>Top-Level Symbols</h2>
    <table>
      <thead><tr><th>Name</th><th>Kind</th><th>File</th></tr></thead>
      <tbody>
        ${topLevel
          .sort((a, b) => a.name.localeCompare(b.name))
          .map(
            (s) => `<tr>
            <td><a href="symbols/${s.id}.html">${escapeHtml(s.name)}</a></td>
            <td><span class="badge ${badgeClass(s.kind)}">${s.kind}</span></td>
            <td><a href="files/${fileSlug(s.file)}.html">${escapeHtml(s.file)}</a></td>
          </tr>`,
          )
          .join("")}
      </tbody>
    </table>

    <h2>Search</h2>
    <input type="text" class="search-box" id="search" placeholder="Search symbols..." oninput="doSearch(this.value)">
    <ul class="search-results" id="results"></ul>
    <script>
      var searchData = [];
      fetch('search.json').then(function(r){return r.json();}).then(function(d){searchData=d;});
      function doSearch(q) {
        var r = document.getElementById('results');
        r.textContent = '';
        if (!q) return;
        var lq = q.toLowerCase();
        var matches = searchData.filter(function(s){
          return s.name.toLowerCase().indexOf(lq) !== -1 || s.kind.indexOf(lq) !== -1;
        });
        matches.slice(0, 20).forEach(function(s) {
          var li = document.createElement('li');
          var a = document.createElement('a');
          a.href = 'symbols/' + s.id + '.html';
          a.textContent = s.name;
          var span = document.createElement('span');
          span.className = 'badge ' + s.badgeClass;
          span.textContent = s.kind;
          li.appendChild(a);
          li.appendChild(document.createTextNode(' '));
          li.appendChild(span);
          r.appendChild(li);
        });
      }
    </script>
  `;

  return layout("Dashboard", "index.html", body);
}

export function renderSymbolPage(
  symbol: CodeSymbol,
  allSymbols: CodeSymbol[],
  relationships: RelationshipRow[],
  sourceCode?: string,
): string {
  const children = allSymbols.filter((s) => s.parent === symbol.id);
  const outgoing = relationships.filter((r) => r.source_id === symbol.id);
  const incoming = relationships.filter((r) => r.target_id === symbol.id);

  // Extract source code snippet
  let sourceSnippet = "";
  if (sourceCode) {
    const lines = sourceCode.split("\n");
    const start = Math.max(0, symbol.startLine - 1);
    const end = Math.min(lines.length, symbol.endLine);
    const snippet = lines.slice(start, end);
    // Add line numbers
    const numbered = snippet
      .map((line, i) => `${String(start + i + 1).padStart(4)} | ${line}`)
      .join("\n");
    sourceSnippet = numbered;
  }

  // Per-symbol dependency graph
  const depGraph = buildMermaidForSymbol(symbol, allSymbols, relationships, "outgoing");
  // Per-symbol impact graph (who depends on me)
  const impactGraph = buildMermaidForSymbol(symbol, allSymbols, relationships, "incoming");

  const body = `
    <h1><span class="badge ${badgeClass(symbol.kind)}">${symbol.kind}</span> ${escapeHtml(symbol.name)}</h1>

    <div class="card">
      <p><strong>File:</strong> <a href="../files/${fileSlug(symbol.file)}.html">${escapeHtml(symbol.file)}</a>:${symbol.startLine}-${symbol.endLine}</p>
      ${symbol.signature ? `<p><strong>Signature:</strong> <code>${escapeHtml(symbol.signature)}</code></p>` : ""}
      ${symbol.pattern ? `<p><strong>Pattern:</strong> ${escapeHtml(symbol.pattern)}</p>` : ""}
      ${symbol.metrics ? `<p><strong>Metrics:</strong> LOC: ${symbol.metrics.linesOfCode ?? "-"}, Complexity: ${symbol.metrics.cyclomaticComplexity ?? "-"}, Params: ${symbol.metrics.parameterCount ?? "-"}</p>` : ""}
    </div>

    ${
      sourceSnippet
        ? `<h2>Source Code</h2>
    <pre><code>${escapeHtml(sourceSnippet)}</code></pre>`
        : ""
    }

    ${
      children.length > 0
        ? `<h2>Members</h2>
    <table>
      <thead><tr><th>Name</th><th>Kind</th><th>Signature</th></tr></thead>
      <tbody>
        ${children
          .map(
            (c) => `<tr>
          <td><a href="${c.id}.html">${escapeHtml(c.name)}</a></td>
          <td><span class="badge ${badgeClass(c.kind)}">${c.kind}</span></td>
          <td>${c.signature ? `<code>${escapeHtml(c.signature)}</code>` : "-"}</td>
        </tr>`,
          )
          .join("")}
      </tbody>
    </table>`
        : ""
    }

    ${
      depGraph
        ? `<h2>Dependencies</h2>
    <div class="mermaid">${depGraph}</div>`
        : ""
    }

    ${
      outgoing.length > 0
        ? `<table>
      <thead><tr><th>Target</th><th>Type</th></tr></thead>
      <tbody>
        ${outgoing
          .map((r) => {
            const target = allSymbols.find((s) => s.id === r.target_id);
            return `<tr>
          <td>${target ? `<a href="${target.id}.html">${escapeHtml(target.name)}</a>` : r.target_id}</td>
          <td>${r.type}</td>
        </tr>`;
          })
          .join("")}
      </tbody>
    </table>`
        : ""
    }

    ${
      impactGraph
        ? `<h2>Impact (depended by)</h2>
    <div class="mermaid">${impactGraph}</div>`
        : ""
    }

    ${
      incoming.length > 0
        ? `<table>
      <thead><tr><th>Source</th><th>Type</th></tr></thead>
      <tbody>
        ${incoming
          .map((r) => {
            const source = allSymbols.find((s) => s.id === r.source_id);
            return `<tr>
          <td>${source ? `<a href="${source.id}.html">${escapeHtml(source.name)}</a>` : r.source_id}</td>
          <td>${r.type}</td>
        </tr>`;
          })
          .join("")}
      </tbody>
    </table>`
        : ""
    }

    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true,theme:'default'});</script>
  `;

  return layout(symbol.name, "", body, 1);
}

export function renderFilePage(
  filePath: string,
  symbols: CodeSymbol[],
  sourceCode?: string,
): string {
  const topLevel = symbols.filter((s) => !s.parent);
  const allSymbols = symbols;

  const body = `
    <h1>${escapeHtml(filePath)}</h1>

    <table>
      <thead><tr><th>Name</th><th>Kind</th><th>Lines</th><th>Signature</th></tr></thead>
      <tbody>
        ${topLevel
          .sort((a, b) => a.startLine - b.startLine)
          .map((s) => {
            const children = allSymbols.filter((c) => c.parent === s.id);
            return `<tr>
          <td><a href="../symbols/${s.id}.html">${escapeHtml(s.name)}</a></td>
          <td><span class="badge ${badgeClass(s.kind)}">${s.kind}</span></td>
          <td>${s.startLine}-${s.endLine}</td>
          <td>${s.signature ? `<code>${escapeHtml(s.signature)}</code>` : "-"}</td>
        </tr>
        ${children
          .map(
            (c) => `<tr>
          <td style="padding-left:2rem"><a href="../symbols/${c.id}.html">${escapeHtml(c.name)}</a></td>
          <td><span class="badge ${badgeClass(c.kind)}">${c.kind}</span></td>
          <td>${c.startLine}-${c.endLine}</td>
          <td>${c.signature ? `<code>${escapeHtml(c.signature)}</code>` : "-"}</td>
        </tr>`,
          )
          .join("")}`;
          })
          .join("")}
      </tbody>
    </table>

    ${
      sourceCode
        ? `<h2>Full Source</h2>
    <pre><code>${escapeHtml(sourceCode)}</code></pre>`
        : ""
    }
  `;

  return layout(filePath, "", body, 1);
}

export function renderRelationshipsPage(
  relationships: RelationshipRow[],
  symbols: CodeSymbol[],
): string {
  const symbolMap = new Map(symbols.map((s) => [s.id, s]));

  // Group relationships by type for summary
  const byType: Record<string, number> = {};
  for (const r of relationships) {
    byType[r.type] = (byType[r.type] ?? 0) + 1;
  }

  const body = `
    <h1>Relationships</h1>

    <div class="stats">
      ${Object.entries(byType)
        .sort((a, b) => b[1] - a[1])
        .map(
          ([type, count]) => `
        <div class="stat">
          <div class="number">${count}</div>
          <div class="label">${type}</div>
        </div>`,
        )
        .join("")}
    </div>

    <p>Each symbol page contains focused dependency and impact graphs. Below is the full relationship table.</p>

    <h2>All Relationships</h2>
    <table>
      <thead><tr><th>Source</th><th>Type</th><th>Target</th></tr></thead>
      <tbody>
        ${relationships
          .map((r) => {
            const source = symbolMap.get(r.source_id);
            const target = symbolMap.get(r.target_id);
            return `<tr>
          <td>${source ? `<a href="symbols/${source.id}.html">${escapeHtml(source.name)}</a>` : r.source_id}</td>
          <td>${r.type}</td>
          <td>${target ? `<a href="symbols/${target.id}.html">${escapeHtml(target.name)}</a>` : r.target_id}</td>
        </tr>`;
          })
          .join("")}
      </tbody>
    </table>
  `;

  return layout("Relationships", "relationships.html", body);
}

export function renderPatternsPage(
  patterns: DetectedPattern[],
  symbols: CodeSymbol[],
): string {
  const symbolMap = new Map(symbols.map((s) => [s.id, s]));

  const body = `
    <h1>Detected Patterns</h1>

    ${
      patterns.length === 0
        ? "<p>No patterns detected.</p>"
        : patterns
            .map(
              (p) => `
      <div class="card">
        <h3>${escapeHtml(p.kind)} <small>(confidence: ${(p.confidence * 100).toFixed(0)}%)</small></h3>
        <p><strong>Symbols:</strong> ${p.symbols
          .map((id) => {
            const s = symbolMap.get(id);
            return s
              ? `<a href="symbols/${s.id}.html">${escapeHtml(s.name)}</a>`
              : id;
          })
          .join(", ")}</p>
        ${
          p.violations.length > 0
            ? `<p><strong>Violations:</strong></p><ul>${p.violations
                .map((v) => `<li>${escapeHtml(v)}</li>`)
                .join("")}</ul>`
            : ""
        }
      </div>`,
            )
            .join("")
    }
  `;

  return layout("Patterns", "patterns.html", body);
}

export function buildSearchIndex(symbols: CodeSymbol[]): object[] {
  return symbols.map((s) => ({
    id: s.id,
    name: s.name,
    kind: s.kind,
    file: s.file,
    badgeClass: badgeClass(s.kind),
  }));
}
